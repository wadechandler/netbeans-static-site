<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META NAME="keywords" CONTENT="netbeans,magazine,NetBeans,6.0,features">
<META NAME="description" CONTENT="NetBeans Magazine: NetBeans IDE 6.0 - New Core Features in Depth">
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>NetBeans IDE 6.0 - New Core Features in Depth</title>
<style>
<!--
p.Noparagraphstyle, li.Noparagraphstyle, div.Noparagraphstyle
	{line-height:120%;
	text-autospace:none;
	font-size:12.0pt;
	font-family:Times;
	color:black;}
p.NB-Corpo, li.NB-Corpo, div.NB-Corpo
	{text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
p.NB-Interttulo, li.NB-Interttulo, div.NB-Interttulo
	{line-height:120%;
	page-break-after:avoid;
	text-autospace:none;
	font-size:13.0pt;
	font-family:"Verdana";
	color:#BC001C;
	font-weight:bold;}
p.NB-Interttulo2, li.NB-Interttulo2, div.NB-Interttulo2
	{line-height:12.0pt;
	page-break-after:avoid;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:#D33823;
	font-weight:bold;}
p.NB-Notadica, li.NB-Notadica, div.NB-Notadica
	{text-align:left;
	line-height:13.0pt;
	tab-stops:14.15pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Verdana";
	color:#D33823;
	letter-spacing:.05pt;}
p.NB-Cdigointerno, li.NB-Cdigointerno, div.NB-Cdigointerno
	{line-height:10.0pt;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Verdana";
	color:black;}
p.Caption, li.Caption, div.Caption
	{text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	color:black;}
p.NB-Legendaimagem, li.NB-Legendaimagem, div.NB-Legendaimagem
	{line-height:12.0pt;
	tab-stops:14.15pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:.05pt;}
span.TechText
	{font-family:"Verdana";
	letter-spacing:0pt;
	font-weight:bold;}
span.NB-NegritoTcnico
	{font-family:"Verdana";
	color:black;
	letter-spacing:.05pt;
	font-weight:bold;
	vertical-align:baseline;}
span.NB-Legendanegrito
	{font-weight:bold;}
div.NB-Cdigointerno1 {line-height:10.0pt;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Verdana";
	color:black;}
div.NB-Corpo1 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
div.NB-Interttulo1 {line-height:120%;
	page-break-after:avoid;
	text-autospace:none;
	font-size:13.0pt;
	font-family:"Verdana";
	color:#BC001C;
	font-weight:bold;}
div.NB-Interttulo21 {line-height:12.0pt;
	page-break-after:avoid;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:#D33823;
	font-weight:bold;}
div.NB-Notadica1 {text-align:left;
	line-height:13.0pt;
	tab-stops:14.15pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Verdana";
	color:#D33823;
	letter-spacing:.05pt;}
div.Noparagraphstyle1 {line-height:120%;
	text-autospace:none;
	font-size:12.0pt;
	font-family:Times;
	color:black;}
li.NB-Cdigointerno1 {line-height:10.0pt;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Verdana";
	color:black;}
li.NB-Corpo1 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
li.NB-Interttulo1 {line-height:120%;
	page-break-after:avoid;
	text-autospace:none;
	font-size:13.0pt;
	font-family:"Verdana";
	color:#BC001C;
	font-weight:bold;}
li.NB-Interttulo21 {line-height:12.0pt;
	page-break-after:avoid;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:#D33823;
	font-weight:bold;}
li.NB-Notadica1 {text-align:left;
	line-height:13.0pt;
	tab-stops:14.15pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Verdana";
	color:#D33823;
	letter-spacing:.05pt;}
li.Noparagraphstyle1 {line-height:120%;
	text-autospace:none;
	font-size:12.0pt;
	font-family:Times;
	color:black;}
p.NB-Cdigointerno1 {line-height:10.0pt;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Verdana";
	color:black;}
p.NB-Corpo1 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
p.NB-Interttulo1 {line-height:120%;
	page-break-after:avoid;
	text-autospace:none;
	font-size:13.0pt;
	font-family:"Verdana";
	color:#BC001C;
	font-weight:bold;}
p.NB-Interttulo21 {line-height:12.0pt;
	page-break-after:avoid;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:#D33823;
	font-weight:bold;}
p.NB-Notadica1 {text-align:left;
	line-height:13.0pt;
	tab-stops:14.15pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Verdana";
	color:#D33823;
	letter-spacing:.05pt;}
p.Noparagraphstyle1 {line-height:120%;
	text-autospace:none;
	font-size:12.0pt;
	font-family:Times;
	color:black;}
span.NB-Legendanegrito1 {font-weight:bold;}
span.NB-NegritoTcnico1 {font-family:"Verdana";
	color:black;
	letter-spacing:.05pt;
	font-weight:bold;
	vertical-align:baseline;}
span.TechText1 {font-family:"Verdana";
	letter-spacing:0pt;
	font-weight:bold;}
p.NB-Corpo22 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo221 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo2211 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo2212 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo22121 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo221211 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo2212111 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;
	letter-spacing:-.05pt;}
p.NB-Corpo11 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
p.NB-Corpo111 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
.NB-Listagenstitulos {font-family: Verdana, Arial, Helvetica, sans-serif;
	color: #FFFFFF;
	font-size: 14px;}
.style4 {font-size: 11px; font-weight: bold; color: #BC001C;}
.style5 {font-size: 14px}
p.NB-Corpo1111 {text-align:left;
	text-indent:5.65pt;
	line-height:16.0pt;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Verdana";
	color:black;}
.style6 {font-family: "Courier New", Courier, monospace}
-->
</style>
</head>
<body bgcolor="#FFFFFF" lang=PT-BR>
<table width="770" border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td height="200"><img src="/images_www/magazine/nb06/top_nb6.jpg" alt="Title" width="770" height="200"></td>
  </tr>
  <tr>
    <td><p class="NB-Corpo style5"><strong><br>
        New features and improvements in the next release of NetBeans make it a better IDE for any kind of developer. From editing to browsing, versioning, building, debugging, profiling or visual design, there are great news for everybody.<br>
        <br>
        <br>
        </strong></p></td>
  </tr>
  <tr>
    <td><p class=NB-Corpo1>It&rsquo;s that time again. A major, dot-zero
        release of NetBeans will be available soon &ndash; about a year and a half after 5.0,
        which introduced significant new features like the Matisse GUI builder, and
        extensive improvements in CVS integration, web services and module development,
        to cite but a few. In contrast, version 5.5 focused outside the core IDE by
        supporting several new Packs that increased NetBeans&rsquo; overall functionality to
        a level still unmatched by any other open-source IDE. Now, is NetBeans 6.0
        worthy of the bump in the major version number? You bet it is, and in this
        article we&rsquo;ll look at some of the most important and interesting new features
        in the core IDE. </p>
      <p class=NB-Interttulo1><span lang=EN-US style='letter-spacing:-.05pt'>Javac-powered </span></p>
      <p class=NB-Corpo1><b><span lang=EN-US
style='letter-spacing:-.05pt'>L</span></b><span lang=EN-US
style='letter-spacing:-.05pt'>et&rsquo;s begin by looking not at an end-user feature
        but at a core IDE technology that provides the foundation for many enhancements.
        Past releases of NetBeans, like many other programming tools, contained custom
        code to parse Java sources and assist in code understanding and manipulation
        tasks (like refactorings, hints and fixes, outlining, etc). The result was
        sometimes limited functionality: simple highlighting, non-bulletproof
        refactorings, and the lack of support for features like code completion
        everywhere Java code appears. </span></p>
      <p class=NB-Corpo1>The obvious solution would be reusing the mature
        technology of the javac compiler to do all Java source processing. But javac
        was not designed to support the requirements of a modern IDE: it was written
        and tuned for batch execution, and to accept as input full compilation units,
        perform a complete compilation and produce <i>.class</i> files as output. </p>
      <p class=NB-Corpo1>IDEs have very different requirements, among which
        the most critical is working in memory only. Suppose that after each character
        you type, the IDE wants to analyze the entire class again so it can update
        syntax error indications, perform highlighting, and provide other features that
        depend on the code structure. One option would be to write the editor&rsquo;s current
        content to a temporary file, invoke javac and parse the resulting <i>.class</i> files. But this would be very inefficient. </p>
      <p class=NB-Corpo1>A much better solution is to call javac in the
        same process (as a local library), then pass the current sources as an
        in-memory parameter and receive in return the data structures containing the
        same information that would be present in the class files (which wouldn&rsquo;t need
        to be created). Up to Java SE 5, this solution would be possible, but only
        using the proprietary &ndash; and often unstable &ndash; internal APIs of a Java compiler. </p>
      <p class=NB-Corpo1>This situation changed with Java SE 6, which
        introduced JSR 199 (Java Compiler API) and JSR 269 (Pluggable Annotation Processing
        API). The Java Compiler API enables tight and efficient integration with javac
        (and other Java source compilers), and JSR 269 &ndash; although initially designed
        for annotation processing &ndash; provides a source-level equivalent of reflection
        metadata. Working together, these new APIs allow IDEs and other tools to dig
        deeply into the structural information that javac extracts from source code.
        Additionally, javac&rsquo;s implementation was enhanced and tuned for embedded and
        interactive use. </p>
      <p class=NB-Corpo1>NetBeans was heavily updated to integrate with
        these new capabilities, enabling many improvements in the IDE (discussed
        below). The changes also promise future benefits: when Java SE 7 comes out with
        a new set of language enhancements, you should expect NetBeans&rsquo; toolset to
        catch up very fast. </p>
      <p class=NB-Interttulo1><span lang=EN-US style='letter-spacing:-.05pt'>A new
        editor </span></p>
      <p class=NB-Corpo1><span lang=EN-US
style='letter-spacing:-.05pt'>Common sense says no product can be perfect in
        everything it does, but NetBeans is getting closer each day. Historically,
        NetBeans users have been proud of the IDE&rsquo;s complete coverage of Java platforms
        from ME to EE, its support for effective GUI building, and its intuitive UI and
        open architecture. On the other hand, the IDE lagged in certain areas, like in
        the code editor or refactoring. This could put off programmers very focused in
        source code&hellip; types who&rsquo;ll pick <i>emacs</i> over visual designers any day.
        Well, these prob</span><span lang=EN-US>lems are no more with NetBeans 6.0. </span><br>
        <br>
      </p>
      <p class=NB-Interttulo21><span lang=EN-US>AST-based selection</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Selecting words or lines is good enough for
        text editors, but when working with sources you often need to work with ranges
        of text that form coherent pieces of code. Say you want to copy all the code
        inside a </span><span class=TechText1><span lang=EN-US style='font-size:10.0pt'>for</span></span><span
lang=EN-US> loop body in order to paste it in another loop with
        similar logic. Just place the cursor in any blank position inside the loop
        body, press <i>Alt+Shift+Up </i>and you&rsquo;re done. The editor selects the
        innermost range of text that includes the cursor position, and delimits a node
        of the source&rsquo;s Abstract Syntax Tree.</span></p>
      <p class=NB-Notadica1><span lang=EN-US
style='letter-spacing:.1pt'><strong>Note: </strong>The Java compiler (as do most compilers) parses
        source code into an intermediary representation, which is structured as a tree.
        Each node in this data structure (called an Abstract Syntax Tree) represents a
        code element: a class, method, statement, block, identifier, operator, literal,
        etc. Though code processing tools usually manipulate programs as ASTs, many use
        a simple parser that produces only a basic tree. The &ldquo;full&rdquo; AST produced by a
        complete compiler like javac, which is capable of semantic analysis and code
        generation, will contain very detailed and reliable information about each
        node. For example, the node for an identifier holds not only its name but also
        its type and its &rdquo;definite assignment&rdquo; status (whether the identifier is
        guaranteed to be initialized at a given point); it can even hold its
        statically-calculated value (when applicable). Tools that work on top of a full
        AST are much more powerful and reliable. The difference won&rsquo;t be noticeable for
        a simple selection feature, but it may be very significant for more
        sophisticated functionality like refactorings. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:-.2pt'>Pressing <i>Alt+Shift+Up </i>again expands the selection to the next outer node, in this case the
        complete </span><span class=TechText1><span lang=EN-US style='font-size:10.0pt;
letter-spacing:-.2pt'>for</span></span><span lang=EN-US style='letter-spacing:
-.2pt'> statement; then a new keystroke may select the entire method, and so
        forth. <i>Alt+Shift+Down </i>will retract the selection to an inner node. <b>Figure
        1</b> shows this feature being used to select a multi-line statement easily and
        precisely. I bet you will quickly be hooked on this feature and forget about
        all the other selection shortcuts! There&rsquo;s nothing like a code editor that
        groks <i>code</i>, not text. </span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><div align="center"><img src="/images_www/magazine/nb06/images/figura1.png" width="700" height="460"></div></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo22><strong>Figure 1.</strong> Several new editor features in action.<br>
            </p></td>
        </tr>
      </table>
      <p class=NB-Interttulo21><span lang=EN-US>Semantic highlighter</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The editor&rsquo;s syntax highlighter was promoted
        to a semantics-aware highlighter. It can apply styles based not only on the
        types of tokens (like identifiers, operators or comments), but also based on
        different meanings that akin tokens may have &ndash; for instance, an identifier may
        be a class name or a local variable name, a parameter, a constant field, etc. </span></p>
      <p class=NB-Corpo1><span lang=EN-US>One benefit of semantic highlighting is that
        it helps you take extra care when assigning to </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>static</span></span><span
lang=EN-US> fields (since many thread-safety and memory-leak bugs involve
        statics). <b>Figure 1</b> shows this off; notice that static fields (and
        references to these) appear in italics. </span></p>
      <p class=NB-Corpo1><span lang=EN-US>There are other powerful uses for the new
        highlighting engine:</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Identifying usages &ndash;</span></i><span
lang=EN-US> Select any identifier, and the editor highlights all its uses in
        the same compilation unit. Again, <b>Figure 1</b> exemplifies this: clicking on
        a method name, all invocations to it are highlighted.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Flagging &ldquo;Smelly code&rdquo; &ndash;</span></i><span
lang=EN-US> The new editor highlights unused variables and imports, as well as
        usage of deprecated classes and methods. You don&rsquo;t need to perform a build or
        run a code lint tool to detect these simple (but frequent) problems anymore.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Exit and throw points</span></i><span
lang=EN-US> &ndash; Selecting a method&rsquo;s return type will highlight all </span><span
class=TechText1><span lang=EN-US style='font-size:10.0pt'>return</span></span><span
lang=EN-US> statements. Selecting an exception in the method&rsquo;s </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>throws</span></span><span
lang=EN-US> list will flag all </span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>throw</span></span><span lang=EN-US>&rsquo;s of
        that exception type. All invocations to other methods that may throw the same
        exception are also flagged.</span><br>
      </p>
      <p class=NB-Interttulo21><span lang=EN-US>Better code completion</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The bewildering amount of APIs you have to
        use these days makes code completion one of the most critical features of any
        modern code editor. NetBeans 6.0 has learned many new tricks here:</span></p>
      <p class=NB-Corpo1><span lang=EN-US style='font-family:Wingdings;'>&sect;</span><span lang=EN-US> <i>Keyword completion</i> &ndash; If you&rsquo;ve just
        typed a </span><span class=NB-NegritoTcnico1><span lang=EN-US style='font-size:
10.0pt'>package</span></span><span lang=EN-US> declaration in a new source file
        (for example), <i>Alt+Space</i> will bring only the keywords that are legal in
        that position: </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>abstract</span></span><span lang=EN-US>, </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>class</span></span><span
lang=EN-US>, </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>enum</span></span><span lang=EN-US>, </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>final</span></span><span
lang=EN-US>, </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>import</span></span><span lang=EN-US>, </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>interface</span></span><span
lang=EN-US> and </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>public</span></span><span lang=EN-US>. <b>Figure 1</b> shows another example: after the opening parenthesis of a method declaration,
        the preferred completions are all primitive types. </span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Type-based variable names</span></i><span
lang=EN-US> <i>&ndash;</i> Completing at &ldquo;</span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>ConfigurationFile</span></span><span
lang=EN-US> _&rdquo;, the editor will offer the variable names </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>cf</span></span><span
lang=EN-US>, </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>configurationFile</span></span><span lang=EN-US> and </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>file</span></span><span
lang=EN-US>. (I&rsquo;m using &ldquo;</span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>_</span></span><span lang=EN-US>&rdquo; to represent the
        cursor position.)</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Generics-aware completions &ndash;</span></i><span
lang=EN-US> When assigning a variable with a generic type to a </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>new</span></span><span
lang=EN-US> expression, the editor will offer all compatible types, including
        generic arguments. For example, at &ldquo;</span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>Map&lt;String, Integer&gt; m = new _</span></span><span
lang=EN-US>&rdquo;, code completion lists all implementations of </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>Map</span></span><span
lang=EN-US>, each with the same </span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>&lt;String, Integer&gt;</span></span><span
lang=EN-US> parameters.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Annotation-aware completions</span></i><span
lang=EN-US> &ndash; When completing after &ldquo;</span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>@&rdquo;</span></span><span lang=EN-US>, you&rsquo;ll
        be offered all the annotations that can be used in the given scope. And if the
        selected annotation requires parameters the editor will provide completions for
        these too.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Passing parameters &ndash; </span></i><span
lang=EN-US>At &ldquo;</span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>x = m(_</span></span><span lang=EN-US>&rdquo;, the top
        completions will be values in scope that are compatible with </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>m()</span></span><span
lang=EN-US>&rsquo;s first parameter. If the method&rsquo;s parameter names are available
        and there are variables with similar names in scope, this is used to sort the
        completions further. You&rsquo;ll also be offered full completions with the parameter
        list filled with those variables.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Common constructors &ndash;</span></i><span
lang=EN-US> When you invoke code completion with the cursor positioned between
        class members, you&rsquo;ll be offered to create a constructor without arguments and
        one that receives initial values for all fields (if these constructors don&rsquo;t
        already exist).</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Catching exceptions &ndash;</span></i><span
lang=EN-US> Completion at &ldquo;</span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt'>catch (_</span></span><span lang=EN-US>&rdquo;
        will only offer exceptions that are thrown in the corresponding </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>try</span></span><span
lang=EN-US> block, but haven&rsquo;t been handled yet by previous </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>catch</span></span><span
lang=EN-US> blocks.</span><br>
      </p>
      <p class=NB-Interttulo21><span lang=EN-US>New browsing views</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The editor introduces several new views for
        source code browsing. The <i>Members view s</i>hows the members of a Java type
        together with their javadocs, making it easy to find a particular method, field
        or inner class. The <i>Hierarchy </i>view <i>s</i>hows the inheritance tree of
        a Java type. <b>Figure&nbsp;1</b> demonstrates this view; notice the filter
        buttons that let you toggle between supertypes or subtypes and between simple
        and fully qualified class names. You can also choose whether or not to show
        inner classes and interfaces.<i> </i></span></p>
      <p class=NB-Corpo1><span lang=EN-US>The<i> Declaration </i>view<i> s</i>ummarizes
        the declaration of the selected Java element (type, method or field). Despite
        its name, this view also shows the inspected element&rsquo;s source code if it&rsquo;s
        available. The Declaration View is especially useful when invoking code still
        under development, not yet documented with javadoc.<i> </i>Finally,<i> </i>the<i> Javadoc </i>view<i> s</i>hows the javadocs for the selected Java element.</span><br>
      </p>
      <p class=NB-Interttulo21><span lang=EN-US>Editable Diff and Inline Diff</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The editor&rsquo;s improved architecture makes it
        easier for various features that handle source code to integrate editor
        functionality. This is noticeable in the new Diff (opened, for example, by
        selecting a source file and choosing <i>Subversion&gt;Diff</i>). When it&rsquo;s
        showing a local file, the right pane is editable, providing the full set of
        editor features &ndash; semantic highlighting and code completion included.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The new Diff adds other interesting tricks,
        like one-click merging and word-level diff (if a single word is changed in a
        line, only that word is highlighted). Check out these improvements in <b>Figure&nbsp;2</b>.</span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure3.png" width="561" height="245"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo221><strong>Figure 2.</strong> The Local History and the new Diff: editing capability, semantic highlighting and word-level diff.<br>
            </p></td>
        </tr>
      </table>
      <br>
      <p class=NB-Corpo1><span lang=EN-US>You can also enable an Inline Diff feature,
        which creates a Diff sidebar, highlighting updated sections of a versioned
        file. The sidebar lets you visualize or rollback changes, and open the full
      Diff view.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Javadoc hints</span></p>
      <p class=NB-Corpo1><span lang=EN-US>You always document all your code, right?
        Well, if you don&rsquo;t, NetBeans will complain about missing and incorrect javadoc
        tags. The IDE can help you with automatic fixes that add the missing tags, only
        asking you to fill in the blanks. And while you&rsquo;re doing that, you can use the
        new Javadoc view for convenient previewing.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Javadoc checking is active by default, but
        it&rsquo;s not intrusive: the editor will report missing javadoc tags just for the
        selected line; only incorrect tags will be reported everywhere. You can
        customize these and related options through <i>Tools|Options&gt;Java
      Code&gt;Hints</i>.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Other features</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The new editor and its framework include
        other general features, like reusable editor tabs. These are useful for the
        debugger, to avoid cluttering your environment with editors opened by
        breakpoints or step-into&rsquo;s. There&rsquo;s also a new <i>Generate Code </i>dialog that
        automates the creation of constructors, getters and setters, </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>equals()</span></span><span
lang=EN-US> and </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>hashCode()</span></span><span lang=EN-US>, and delegate
      methods.</span></p>
      <p class=NB-Interttulo1><span lang=EN-US>Refactoring and Jackpot</span></p>
      <p class=NB-Corpo1><span lang=EN-US>NetBeans 6.0 improves the existing
        refactoring support extensively. There is a new internal language-independent
        refactoring API that will allow implementing refactorings for code other than
        common <i>.java</i> sources (e.g., XML or JSF files). The new API also allows
        Java refactorings to precisely update dependent non-Java elements. This should
        make the current refactorings safer and easier to use. </span></p>
      <p class=NB-Corpo1><span lang=EN-US>The big news here, though, is the
        breakthrough new technology from project Jackpot, which has been available for
        some time but is only reaching maturity now. With its inclusion in NetBeans
        6.0, Jackpot will be promoted to a standard feature and be more closely
        integrated with the IDE.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>You may have heard that Jackpot is a new
        refactoring tool, but this really doesn&rsquo;t make it justice. Jackpot is actually
        a comprehensive framework for general code understanding and manipulation. You
        can use it as a replacement or foundation for several kinds of features:
        refactoring support, advanced searching and browsing, quality inspection,
        macro-like automation of complex editing tasks, <br>
        and more.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Using Jackpot</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Before taking a more in-depth look at
        Jackpot, let&rsquo;s show how easy it is to use. The new <i>Query and Refactor</i> command will show a dialog like <b>Figure&nbsp;3</b>, where you can pick a
        Jackpot query or query set. Some queries have options that you can set to
        preferred values. Click <i>Query</i>, and any matches for the selected queries
        will appear in a view that details each match. Also, if the query involves code
        changes, you can preview and confirm these changes by clicking on a <i>Do
      Refactoring</i> button. </span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure2.png" width="581" height="312"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo2211><strong>Figure 3.</strong> Jackpot&rsquo;s Query and Refactor dialog.<br>
              <br>
            </p></td>
        </tr>
      </table>
      <p class=NB-Interttulo21><span lang=EN-US>Jackpot rules</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Jackpot&rsquo;s full power comes from its
        openness. This requires learning a new language but when you realize Jackpot&rsquo;s
        full potential you will see that the learning curve quickly pays off.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>For example, here is a Jackpot query that
        detects an inefficient code pattern &ndash; the use of </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>equals(&ldquo;&rdquo;)</span></span><span
lang=EN-US> to check if a </span><span class=NB-NegritoTcnico1><span lang=EN-US
style='font-size:10.0pt'>String</span></span><span lang=EN-US> is empty &ndash; and
        rewrites the matching code:</span></p>
      <p class=NB-Cdigointerno1 style6><strong><span lang=EN-US style='font-size:9.0pt'>$s.equals(&ldquo;&rdquo;)
        =&gt; ($s.length() == 0) :: $s instanceof java.lang.String;</span></strong></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>The syntax is </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>pattern =&gt; replacement :: condition</span></span><span lang=EN-US
style='letter-spacing:.1pt'>, where the </span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>$</span></span><span
lang=EN-US style='letter-spacing:.1pt'> character identifies meta-variables
        that will bind to any Java program element (identifier, statement, operator,
        literal, etc.). Let&rsquo;s analyze each clause: </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>1. The pattern </span><span
class=TechText1><span lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>$s.equals(&ldquo;&rdquo;)</span></span><span
lang=EN-US style='letter-spacing:.1pt'> matches invocations to the </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>equals()</span></span><span lang=EN-US style='letter-spacing:.1pt'> method that pass an empty string as argument. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>2. The condition
        is the only optional part of a rule in Jackpot&rsquo;s rule language, but it&rsquo;s a
        critical part in this particular rule: </span><span class=TechText1><span
lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>$s instanceof
        java.lang.String</span></span><span lang=EN-US style='letter-spacing:.1pt'> makes sure that the rule only fires when </span><span class=NB-NegritoTcnico1><span
lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>$s</span></span><span
lang=EN-US style='letter-spacing:.1pt'> is a </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>String</span></span><span lang=EN-US style='letter-spacing:.1pt'>. That&rsquo;s
        an important constraint, since our rule is specific to uses of </span><span
class=TechText1><span lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>java.lang.String.equals()</span></span><span
lang=EN-US style='letter-spacing:.1pt'>, and not to just any implementation of </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>equals()</span></span><span lang=EN-US style='letter-spacing:.1pt'>. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>3. Finally, the
        replacement &ndash; </span><span class=TechText1><span lang=EN-US style='font-size:
10.0pt;letter-spacing:.1pt'>($s.length() == 0)</span></span><span lang=EN-US
style='letter-spacing:.1pt'> &ndash; rewrites the matching code. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>There&rsquo;s a lot of
        sophistication behind this apparently simple behavior. For one thing, look at
        Jackpot&rsquo;s </span><span class=TechText1><span lang=EN-US style='font-size:10.0pt;
letter-spacing:.1pt'>instanceof</span></span><span lang=EN-US style='letter-spacing:
.1pt'> operator. It walks and quacks like Java&rsquo;s </span><span class=TechText1><span
lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>instanceof</span></span><span
lang=EN-US style='letter-spacing:.1pt'>, but it&rsquo;s not the same thing. Java&rsquo;s </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>instanceof</span></span><span lang=EN-US style='letter-spacing:.1pt'> is
        a runtime operator whose left-hand operand is an object reference. Jackpot&rsquo;s </span><span
class=TechText1><span lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>instanceof</span></span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>,</span></span><span lang=EN-US style='letter-spacing:.1pt'> however, is
        a compile-time (static) operator; its left-hand operand is any node of the program&rsquo;s
        AST. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>Because Jackpot
        &ndash; like the new editor &ndash; relies on javac&rsquo;s source analysis engine, it&rsquo;s able to
        fully attribute all types in the processed code. This includes the most complex
        cases, like inferred generic types. Other code analysis tools often resort to
        heuristics that approximate types but might fail to calculate types for some
        expressions. </span></p>
      <p class=NB-Notadica1 style1><span lang=EN-US><strong>Note: </strong>You could even try
        to do our refactoring (<strong>replacing s.equals(&ldquo;&rdquo;) by s.length() == 0</strong>) using
        plain regular expressions: search for (\w*)\.equals\(\&rdquo;\&rdquo;\) and replace it with <strong>$1.length() == 0</strong>. But regexes are rigid and dumb; they won&rsquo;t
        even exclude text that&rsquo;s inside comments or string literals, and a simple line
        break will prevent detection. This is obviously a straw man example (other
        tools, like PMD and FindBugs, are much smarter than regexes &ndash; although not up
        to javac-like precision), but it shows the value of smarter tools/features.</span><span style='font-size:12.0pt;font-family:&quot;Verdana&quot;;Verdana&quot;;letter-spacing:0pt'
lang=EN-US> </span><br>
      </p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>There are
        Jackpot operators without Java counterparts, from simple ones like </span><span
class=TechText1><span lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>isTrue(<i>node</i>)</span></span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>, </span></span><span lang=EN-US style='letter-spacing:.1pt'>which
        matches boolean expressions that can statically be proven to always evaluate to </span><span class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;
letter-spacing:.1pt'>true</span></span><span lang=EN-US style='letter-spacing:
.1pt'> &ndash; to more powerful operators like </span><span class=TechText1><span
lang=EN-US style='font-size:10.0pt;letter-spacing:.1pt'>isSideEffectFree(<i>node</i>)</span></span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt;letter-spacing:
.1pt'>. </span></span><span lang=EN-US style='letter-spacing:.1pt'>The latter
        matches a statement, block or method that doesn&rsquo;t modify any variable outside
        its scope. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.1pt'>Again, such
        detections resemble existing code inspection tools, which detect problems like
        &ldquo;dead code&rdquo;. But Jackpot&rsquo;s reliance on the full javac technology results in
        fewer false positives in detections, and higher safety in automatic
        replacements. </span></p>
      <p class=NB-Notadica1><span lang=EN-US><strong>Note: </strong>You can also write Jackpot queries in
        plain Java, using Jackpot APIs and NetBeans&rsquo; module development features. This is
        necessary for complex rules that go beyond the capabilities of Jackpot&rsquo;s rule
        language. But as this language evolves, fewer and fewer queries should require
        implementation in Java. Performance, by the way, is not an issue: queries
        written in the Jackpot rule language are converted to Java and execute as
        compiled code.</span></p>
      <p class=NB-Corpo1><b><span lang=EN-US style='letter-spacing:.1pt'>Figure&nbsp;4</span></b><span
lang=EN-US style='letter-spacing:.1pt'> shows Jackpot&rsquo;s <i>Refactoring Manager</i>.
        This configuration dialog allows you to inspect all installed queries and
        organize them into query sets. You can also import new queries. If you write a
        new query script, just click <i>Import</i> and the new query will be available
        in the <i>Query and Refactor</i> dialog. </span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure4.png" width="648" height="556"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo2212><strong>Figure 4.</strong> Jackpot&rsquo;s Refactoring Manager.<br>
              <br>
            </p></td>
        </tr>
      </table>
      <p class=NB-Interttulo21><span lang=EN-US>Usage and perspectives</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Jackpot ships with a library of predefined
        queries, containing many rules for code clean-up and detection of common
        programming mistakes or code anti-patterns, as well as migration of deprecated
        API usage.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>As I write this, Jackpot has just been
        integrated into NetBeans. So we have a hybrid system with Jackpot co-existing
        with traditional refactoring and code manipulation features. This means that
        commands like <i>Rename method</i> are still implemented in the old-fashioned
        way, even though they could be implemented by a Jackpot rule. The same holds for
        code validations (&ldquo;hints&rdquo;) and their automatic fixes. Some of this
        functionality will certainly be reimplemented on Jackpot in the future. Also,
        because Jackpot makes the development of such things much easier, you should
        expect an increasing number of refactorings, validations and other
        code-crunching features to be added to the IDE.</span></p>
      <p class=NB-Interttulo1><span lang=EN-US>Extended Ant 
        and JUnit support</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Ant support in NetBeans 6.0 has been updated
        to Ant 1.7.0, a major new release that adds such</span><span lang=EN-US
style='color:red'> </span><span lang=EN-US>features as support for JSR
        223-compatible scripting languages. There&rsquo;s also a new progress indicator for
        Ant processes.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The IDE&rsquo;s JUnit support now handles the
        annotation-driven test cases of JUnit 4. Old JUnit 3.8 test cases are still
        supported. Also, the project properties editor is improved with classpath
        entries specific to unit tests.</span></p>
      <p class=NB-Interttulo1><span lang=EN-US>Project and build features</span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>Editing code is
        fundamental, but for most non-trivial projects a well-structured and powerful
        build system is critical too. NetBeans&rsquo; project management and build system was
        improved with many new features. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>In addition to
        its Ant support, NetBeans can open and understand Apache Maven 2 projects.
        Though the new Maven-based project support is not intended to replace Ant
        projects anytime soon, it will be welcome to Maven fans or to anybody needing
        to build a project that requires Maven. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>Also, now you
        can specify packages or classes to exclude from the source tree. This is useful
        for working with large projects, when you&rsquo;re not interested in seeing or
        running all of their code and a partial build is viable. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>If you have
        many correlated projects, you can organize them into Project Groups, so certain
        operations like opening projects can be applied to the group as a whole.<i> </i>And
        if you write Java SE projects with many entry points (classes with </span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>main()</span></span><span
lang=EN-US style='letter-spacing:.05pt'> methods), or with command-line
        parameters that require frequent edits of the project properties, the <i>Run
        Configurations</i> feature will make your life easier. The project properties&rsquo; <i>Run</i> page shows a new <i>Configuration</i> option. Each configuration allows you to
        define the main class, arguments and VM options, independently of other
        configurations. See an example in <b>Figure&nbsp;5</b>. </span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure5.png" width="712" height="341"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo22121><strong>Figure 5.</strong> Multiple Configurations and support for Java Web Start in the new Project Properties dialog&rsquo;s Run page.<br>
              <br>
            </p></td>
        </tr>
      </table>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>Furthermore,
        the new Java Web Start support automates the creation and maintenance of JNLP
        files, and makes it easier to run tests without needing a browser. In the
        Project Properties, check <i>Application&gt;Web Start&gt;Enable WebStart</i>,
        and off you go. Java Web Start support integrates with the Run Configurations
        feature, by creating a <i>Web Start</i> configuration. So you can test the same
        project with or without JAWS. </span></p>
      <p class=NB-Interttulo1><span lang=EN-US>Version control</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Robust version control is an essential
        feature, even for simple projects written by one developer over a weekend. For
        one thing, it&rsquo;s critical to enable &ldquo;fearless programming&rdquo;, e.g. using
        techniques like refactoring (manual or automatic) without worry. NetBeans 6.0
        brings plenty of news in this area too. </span></p>
      <p class=NB-Interttulo21><span lang=EN-US>CVS</span></p>
      <p class=NB-Corpo1><span lang=EN-US>NetBeans has traditionally supported the CVS
        version control system and this support was already excellent in NetBeans 5.5.
        Version 6.0 adds several updates in usability, like exporting a diff patch of
        files selected in the Search view; a new command to open a specific revision,
        tag or branch; and an improved history search feature with new Summary and Diff
        views. There are also new advanced operations like changing the CVS root and
        doing a partial merge.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Subversion</span></p>
      <p class=NB-Corpo1><span lang=EN-US>The biggest news for many users, though, is
        support for the increasingly popular Subversion version control system.
        NetBeans 6.0 is the first release to integrate complete first-class support for
        SVN. Even though NetBeans 5.5 now offers a Subversion module in the Update
        Center, you really want version 6.0 if you are a heavy Subversion user.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Local History</span></p>
      <p class=NB-Corpo1><span lang=EN-US>No matter which Version Control System you
        prefer, you&rsquo;ll love the new Local History feature, already depicted in <b>Figure&nbsp;2</b>.
        NetBeans 6.0 automatically keeps an internal history of recent changes to
        project resources. Every time you save a file, this is registered as a &ldquo;commit&rdquo;
        of a new version of the file in the local history. So file changes are tracked
        with fine granularity &ndash; somewhat like a persistent undo feature. You can
        inspect the &ldquo;versions&rdquo; in the local history and diff them against the current
        files.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Be warned, however, that this feature is
        mostly useful for undoing mistakes that escape the editor&rsquo;s undo capacity, e.g.
        after closing the editor or restarting the IDE. You can then revert to a
        previous state that you haven&rsquo;t yet committed to a safer VCS repository,
        perhaps because the new code was still rough and untested. The Local History
        feature is powerful and is sometimes a lifesaver, but it&rsquo;s not a full
        replacement for a real VCS.</span></p>
      <p class=NB-Interttulo1><span lang=EN-US>Debugging</span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>The debugger is
        of course among the most critical features of an IDE, and NetBeans is already
        very complete in this area. So what&rsquo;s left to improve in 6.0? First off, the
        Java SE 6 release contains two important new JVM debugging features which
        require an updated debugger to use. (The debuggers from NetBeans 5.5 or older
        releases won&rsquo;t benefit from these even if you run them on top of Java SE 6.)
        There are also other debugger improvements that are not dependent on the JRE
        version, so you&rsquo;ll benefit even if you are chained to some stone-age Java
        runtime like 5.0 or, heavens forbid, 1.4.2. </span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Forcing return values</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Suppose you&rsquo;re stepping anywhere in a method
        and you&rsquo;d like to force it to return immediately and produce a specific return
        value. This is now supported in the 6.0 debugger, letting you check &ldquo;what-if&rdquo;
        scenarios and reproduce bugs more easily. You won&rsquo;t need hacks like patching
        the source code with </span><span class=TechText1><span lang=EN-US
style='font-size:10.0pt'>return</span></span><span lang=EN-US> statements (and
        having to unpatch it later). As I write, this feature is not yet implemented,
        but it should be before the final release.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Expression stepping</span></p>
      <p class=NB-Corpo1><i><span lang=EN-US>Expression stepping</span></i><span
lang=EN-US> is another smart timesaver. In complex expressions containing
        method calls, you can step into individual invocations, and when such a call
        returns you can see the returned value even it&rsquo;s not assigned to any local
        variable. You no longer have to break expressions into simple parts and
        introduce temporary locals for the single purpose of helping debugging. Also,
        the Local Variables view will show the value returned by invoked methods.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Expression stepping will work in any Java
        runtime, but showing values returned by invoked methods requires Java SE 6.</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Multithreading support</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Another new feature that&rsquo;s very useful is <i>Debug
        current thread</i>: you can instruct the debugger so that only a given thread
        will stop in breakpoints. This is crucial for debugging concurrent applications
        that have several threads running the code of interest. Since <i>we</i> developers are not multithreaded, we&rsquo;re easily overwhelmed when setting a
        breakpoint causes the debugger to stop twenty threads at once!</span></p>
      <p class=NB-Interttulo21><span lang=EN-US>Other features</span></p>
      <p class=NB-Corpo1><span lang=EN-US>There are also general improvements to other
        features, like better handling of broken breakpoints (e.g. with incorrect
        conditions), and a command to copy call stacks to the clipboard.</span></p>
      <p class=NB-Interttulo1><span lang=EN-US>New Profiler features</span></p>
      <p class=NB-Corpo1><span lang=EN-US>In NetBeans 6.0, the Profiler becomes part
        of the core distribution, and there&rsquo;s a range of important improvements.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Better performance &ndash;</span></i><span
lang=EN-US> Performance is good anywhere but it&rsquo;s always a critical issue in
        profilers. The NetBeans Profiler, which derives from Sun&rsquo;s JFluid research project,
        pioneered a new technology that allows profiling apps nearly at full speed by
        dynamically instrumenting code. Also, the Profiler itself should be fast to
        analyze and present data collected from the JVM &ndash; especially online data that&rsquo;s
        constantly updated as the program runs. The new release improves significantly
        the performance of the Live Results categorization and drill down, so you&rsquo;ll
        find yourself using this feature more often.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Classloading telemetry &ndash;</span></i><span
lang=EN-US> The VM Telemetry view now shows the number of loaded classes
        together with the number of threads.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Memory snapshot comparison &ndash;</span></i><span
lang=EN-US> Your application has a method that&rsquo;s suspect of leaking? Take heap
        snapshots before and after running it then diff the two snapshots.</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Heap Walker &ndash;</span></i><span lang=EN-US> The ultimate tool for leak hunting and any kind of memory allocation analysis.
        You can load a heap dump and visualize the full object graph in the heap (see <b>Figure&nbsp;6</b></span><span
class=NB-NegritoTcnico1><span lang=EN-US style='font-size:10.0pt'>).</span></span><span
lang=EN-US> </span></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure6.png" width="737" height="478"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo221211><strong>Figure 6.</strong> The Profiler&rsquo;s Heap Walker, inspecting a particular instance of BigInteger.<br>
              <br>
            </p></td>
        </tr>
      </table>
      <br>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;'>&sect;</span><span lang=EN-GB> </span><i><span lang=EN-US>Load generation &ndash;</span></i><span
lang=EN-US> The Profiler supports integration with load generation tools
        (currently only Apache JMeter is supported but more is to come).</span></p>
      <p class=NB-Corpo1><span lang=EN-GB style='font-family:Wingdings;letter-spacing:-.05pt;'>&sect;</span><span
lang=EN-GB style='letter-spacing:-.05pt;'> </span><i><span
lang=EN-US style='letter-spacing:-.05pt'>Profiling Points &ndash; </span></i><span
lang=EN-US style='letter-spacing:-.05pt'>These are a profiler&rsquo;s equivalent of
        debugger breakpoints. You can define places in your source code where the
        profiler should start/stop the clock, reset profiling results or take a
        snapshot. The Profiling Points feature removes most bureaucratic profiling
        work: never again will you need to step or pause code to get snapshots in
        critical events; you also won&rsquo;t need to tweak code to measure the latency of a
        region that doesn&rsquo;t coincide with a full method. </span></p>
      <p class=NB-Interttulo1><span lang=EN-US>GUI and usability</span></p>
      <p class=NB-Corpo1><span lang=EN-US>An IDE should have a beautiful, efficient
        and productive GUI as much as any other application. NetBeans 6.0 makes new
        strides in this direction.</span></p>
      <p class=NB-Corpo1><span lang=EN-US>Linux and Solaris users will certainly
        welcome the much improved GTK L&amp;F, which is now activated by default on
        these platforms. The activated-by-default part depends on Sun&rsquo;s JRE 6 Update 1
        (or better), <span style='letter-spacing:.05pt'>which contains its own share of
        important GTK updates. NetBeans will respect all settings from the active GTK
        theme. </span></span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>The new
        NetBeans Installer (NBI) makes installation easier and faster. In the downloads
        page, you can select which packs you want (e.g. Enterprise, Mobility). Then
        you&rsquo;ll be offered a custom installer that includes all chosen features and will
        install these in a single go. NBI is especially convenient for system
        administrators that need to install the same IDE configuration in multiple
        machines, and for trainers who often land in unprepared laboratories. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>NetBeans also
        includes redesigned icons, and the SDI windowing option (a relic from ancient
        NetBeans releases) was removed. Now you have undockable/floating windows.
        Finally, in the QA front, the new Report Exception tool streamlines reporting of
        detailed error data to NetBeans&rsquo; developers, while the UI Gestures Collector
        can submit data about your IDE usage patterns. This data is useful not only for
        research, but also to implement a kind of &ldquo;tip of the day&rdquo; hint system not
        based on </span><span class=NB-NegritoTcnico1><span lang=EN-US style='font-size:
10.0pt'>Math.random(). </span></span><span lang=EN-US style='letter-spacing:
.05pt'>I tested this, and the NetBeans Analytics site offered me a tutorial
        about profiling multithreaded programs, which was highly correlated with the
        tasks I had been performing in recent days. </span></p>
      <p class=NB-Interttulo1><span lang=EN-US style='letter-spacing:.05pt'>Matisse
        and visual web development </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>There are only
        two core IDE features I&rsquo;m not covering here. Both are award-winning tools and
        top reasons for many developers having moved to NetBeans: the Matisse visual
        editor, and the Visual Web Pack. NetBeans 6.0 brings significant updates to
        both. For Matisse, check out the article &ldquo;UI Design in NetBeans 6.0&rdquo; in this
        issue, where you&rsquo;ll find detailed information about what&rsquo;s new. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>Currently, the
        most important changes in the Visual Web Pack refer to its integration into the
        NetBeans core. Actually, there won&rsquo;t be an external Web Pack for 6.0. The IDE
        already offered support for web application development, so it was a little odd
        to have some of that in the core and the rest in an external Pack.
        Historically, this happened because the Web Pack technology was originally
        developed as a separate product (Sun&rsquo;s Java Studio Creator), which was based on
        a fork of a very old NetBeans version. So its implementation became partially
        redundant with NetBeans&rsquo; web tooling. Now this chasm is closed and there will
        be no more duplicate code or effort. The merge results in a simpler IDE for all
        users: from visual-design lovers to tag-writing diehards. </span></p>
      <p class=NB-Corpo1><span lang=EN-US style='letter-spacing:.05pt'>There are
        several new features in the integrated web tooling but as we write they are
        still under heavy development, so it wasn&rsquo;t viable to cover the new
        functionality in this issue. However, don&rsquo;t miss the article &ldquo;Visual Web
        Application Design with NetBeans&rdquo; for an updated tutorial on the last stable
        version. </span></p>
      <p class=NB-Interttulo1><span lang=EN-US style='letter-spacing:.05pt'>Plugin
        Manager </span></p>
      <p class=NB-Corpo1>NetBeans&rsquo; open,
        extensible architecture is one of its core advantages and it&rsquo;s also very easy
        to use and integrate with. You may be surprised that the <i>Tools&gt;Update
        Manager</i> has disappeared, though. But
        just look again, at <i>Tools&gt;Plugins</i>, and you&rsquo;ll see<b> Figure&nbsp;7. </b></p>
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr>
          <td><img src="/images_www/magazine/nb06/images/figure7.png" width="500" height="418"></td>
        </tr>
        <tr>
          <td><p class=NB-Corpo2212111><strong>Figure 7.</strong> The new Plugin Manager.<br>
              <br>
            </p></td>
        </tr>
      </table>
      <p class=NB-Corpo>The new UI unifies and better organizes the old
        Update Center (see the <i>Updates</i>, <i>New Plugins</i>, <i>Downloaded</i> and <i>Settings</i> tabs), and also the old module manager (see the <i>Installed</i> tab). There are new features too: for example, when you select a plugin (like
        we did for the JMeter Module in <strong>Figure&nbsp;7</strong>),
        a <i>Required Plugins</i> node will appear if applicable; you can expand it
        to see any dependencies that must also be installed. </p>
      <p class=NB-Interttulo1><span lang=EN-US style='letter-spacing:.05pt'>Conclusions </span></p>
      <p class=NB-Corpo1>NetBeans 6.0 comes with a massive number of new
        and improved features and certainly deserves the major version bump. If
        NetBeans 5.5 was wide, NetBeans 6.0 is also deep. Developers upgrading to the
        latest version will have not only extensive support for all kinds of Java
        development but also a best-of-breed feature set in every important
        functionality area. </p>
      <p class=NB-Corpo1><span lang=EN-US>Many
        NetBeans power users may have gone through this article and found features that
        were already available for previous versions via additional modules. From
        several editor enhancements to Run Configurations, to the Local History, you
        could find an <i>nbm</i> file that would provide some level of support for your
        need. However, you can now just install the core IDE and have all these
        features out of the box &ndash; and they&rsquo;re superior, more polished and better
        integrated than what&rsquo;s provided through external modules. This happens of
        course with every new release, but NetBeans 6.0 makes a very noticeable effort
        to catch up with its RFEs, embracing a large number of improvements that first
        surfaced as contributions from the broader community. This can only be viewed
        as great news, and as evidence of a project that moves fast in the direction
        users want.</span><span
lang=EN-US style='color:#D33823'> </span></p>
      <table width="100%" border="1" cellpadding="0" cellspacing="0" bordercolor="#BC001C">
        <tr>
          <td height="24" valign="middle" bgcolor="#BC001C"><p class="NB-Listagenstitulos"><strong>Links</strong></p></td>
        </tr>
        <tr>
          <td><table width="100%" border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td width="40">&nbsp;</td>
                <td><a href="http://wiki.netbeans.org/Jackpot"><span class="style4"><font face="Verdana">jackpot.netbeans.org</font></span></a></td>
              </tr>
              <tr>
                <td>&nbsp;</td>
                <td><font size=1 color=black face="Verdana"><span style="font-size:9.0pt;letter-spacing:0pt">The Jackpot project.</span></font></td>
              </tr>
            </table>
            <br>
            <table width="100%" border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td width="40">&nbsp;</td>
                <td><a href="http://www.netbeans.info/downloads/dev.php"><span class="style4"><font face="Verdana">www.netbeans.info/downloads/dev.php</font></span></a></td>
              </tr>
              <tr>
                <td>&nbsp;</td>
                <td><font size=1 color=black face="Verdana"><span style="font-size:9.0pt;letter-spacing:0pt">NetBeans 6.0 development builds.</span></font></td>
              </tr>
            </table>
            <br>
            <table width="100%" border="0" cellspacing="0" cellpadding="0">
              <tr>
                <td width="40">&nbsp;</td>
                <td><a href="http://installer.netbeans.org"><span class="style4"><font face="Verdana">installer.netbeans.org</font></span></a></td>
              </tr>
              <tr>
                <td>&nbsp;</td>
                <td><font size=1 color=black face="Verdana"><span style="font-size:9.0pt;letter-spacing:0pt">The new NetBeans Installer. As of this writing, you must follow a link to a directory where you&rsquo;ll navigate to the installer page for a specific build</span></font><font color=black face="Verdana"><span style="font-size:9.0pt;letter-spacing:0pt">.</span></font></td>
              </tr>
            </table></td>
        </tr>
      </table>
      <br>
      <table width="770" border="1" cellpadding="0" cellspacing="0" bordercolor="#BC001C">
        <tr>
          <td><table width="100%" border="0" cellpadding="0" cellspacing="1" bordercolor="#BC001C">
              <tr>
                <td width="93"><div align="center"><img src="/images_www/magazine/autores/Osvaldo-Doederlein.jpg" alt="Autor" width="80" height="94"></div></td>
                <td width="677" valign="middle"><p class=NB-Corpo1111><strong>Osvaldo Pinali Doederlein</strong><br>
                    (<em>opinali@gmail.com</em>) is a software engineer and consultant, working with Java since 1.0 beta. He&rsquo;s an independent expert for the JCP, having served for JSR-175 (Java SE 5), and is  a Technology Architect at Visionnaire Informatica. Osvaldo has an MSc in Object Oriented Software Engineering, is a contributing editor for Java Magazine and maintains a blog at <a href="http://weblogs.java.net/blog/opinali"><span class="style4"><font face="Verdana">weblogs.java.net/blog/opinali</font></span></a><br>
                  </p></td>
              </tr>
            </table></td>
        </tr>
      </table></td>
  </tr>
</table>
</body>
</html>
